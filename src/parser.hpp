#ifndef PARSER_HPP
#define PARSER_HPP

#include <vector>
#include <memory> // For std::unique_ptr
#include "token.hpp"
#include "ast.hpp"

class Parser {
public:
    // Constructor takes the vector of tokens generated by the lexer.
    Parser(const std::vector<Token>& tokens);

    // Parses the tokens and returns the root of the Abstract Syntax Tree (AST).
    // In this simple case, it returns a single statement. For a full program,
    // it would return a Program node containing a list of statements.
    std::unique_ptr<Stmt> parse();

private:
    const std::vector<Token>& tokens; // Reference to the token stream.
    int current = 0;                   // <--- THIS LINE IS CRUCIAL AND WAS MISSING FROM THE ACTUAL CLASS MEMBER LISTING
                                       // It needs to be a member variable of the Parser class.

    // Helper methods for parsing:
    Token advance();               // Consumes the current token and returns it.
    Token peek() const;            // Looks at the current token without consuming it.
    Token previous() const;        // Looks at the previously consumed token.
    bool isAtEnd() const;          // Checks if the end of the token stream is reached.
    bool check(TokenType type) const; // Checks if the current token is of a specific type.
    bool match(TokenType type);    // Consumes the current token if it matches the given type.

    // Parsing rules / Non-terminals:
    std::unique_ptr<Stmt> statement();      // Parses a general statement.
    std::unique_ptr<PrintStmt> printStatement(); // Parses a 'print' statement.

    // Error reporting
    void error(const Token& token, const std::string& message);
};

#endif // PARSER_HPP